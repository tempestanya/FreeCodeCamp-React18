# Advanced React

## The Need For State

```js
import Starter from "./tutorial/01-useState/starter/01-error-example.jsx";
```

-   in "App.jsx", import the tutorial components one by one for every concept

#### Setup Challenge :

-   create count variable
-   display value in the browser
-   add a button that increases the value of count
-   the value does not increase after pressing the button
-   the reason for the bug - we don't trigger re-rendering (useState Hook)
-   if we need to see the latest changes, we need to setup a state value, and we need to trigger a re-render

```js
const ErrorExample = () => {
    let count = 0;

    const handleClick = () => {
        count = count + 1;
        console.log(count);
    };
    return (
        <div>
            <h2>{count}</h2>
            <button type='button' className='btn' onClick={handleClick}>
                Increment
            </button>
        </div>
    );
};

export default ErrorExample;
```

## useState Basics

-   [Javascript Nuggets - Destructuring (Array)](https://www.youtube.com/watch?v=qhECs40xMec&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=7&t=9s)

```js
import Starter from "./tutorial/01-useState/starter/02-useState-basics.jsx";
```

-   need to import useState hook from react library
-   hook is basically a "function" that react provides
-   returns an array with two elements: the current state value, and a function that we can use to update the state
-   the default state value remains preserved in between the renders, unless changed
-   the `useState()` function accepts a default value as an argument
-   use array destructuring to access the new array items
-   state update triggers a re-render as well

```js
import { useState } from "react";

const UseStateBasics = () => {
    // console.log(useState());

    // const defaultValue = useState("hello")[0];
    // const changeStateFunc = useState("hello")[1];
    // console.log(defaultValue, changeStateFunc);

    const [count, setCount] = useState(0);
    // array destructuring to access values from the new array!

    const handleClick = () => {
        setCount(count + 1);
        // be careful, we can set any value!
        // for example: setCount('pants');
    };
    return (
        <div>
            <h4>You clicked {count} times!</h4>
            <button className='btn' onClick={handleClick}>
                Click Me!
            </button>
        </div>
    );
};

export default UseStateBasics;
```

### Initial Render and Re-Renders

-   In a React application, the initial render is the first time that the component tree is rendered to the DOM. It happens when the application first loads, or when the root component is first rendered. This is also known as "mounting" the components.

-   Re-renders, on the other hand, happen when the component's state or props change, and the component needs to be updated in the DOM to reflect these changes. React uses a virtual DOM to optimize the process of updating the actual DOM, so that only the necessary changes are made.

#### There are a few ways that you can trigger a re-render in a React component:

-   By changing the component's state or props. When the component's state or props change, React will re-render the component to reflect these changes.

-   When the parent element re-renders, even if the component's state or props have not changed.

### General Rules of Hooks

-   starts with "use" (both react and custom hooks)
-   component name must be uppercase
-   invoke inside component/function body
-   don't call hooks conditionally (covered later)
-   set functions don't update the state immediately (covered later)

### useState With Array

```js
import Starter from "./tutorial/01-useState/starter/03-useState-array.jsx";
```

#### Setup Challenge :

-   import data
-   setup a state value
    -   let people be the default value equal to the data
-   display the list of people in the browser

-   create two functions
    -   one that removes a single item from the list
    -   one that clears the entire list

#### Render The List

```js
import { data } from "../../../data";
import { useState } from "react";

const UseStateArray = () => {
    const [people, setPeople] = useState(data);
    // console.log(useState(data));

    return (
        <div>
            {people.map((person) => {
                // console.log(person);
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                    </div>
                );
            })}
        </div>
    );
};

export default UseStateArray;
```

-   don't forget to add the "key" prop when using map method
-   always remember to refer the function, and not invoke it, while handling events

#### Remove Items

```js
import { data } from "../../../data";
import { useState } from "react";

const UseStateArray = () => {
    const [people, setPeople] = useState(data);

    const removeItem = (id) => {
        // console.log(id);
        const newPeople = people.filter((person) => {
            return person.id !== id;
        });
        setPeople(newPeople);
    };
    const clearAllItems = () => {
        setPeople([]);
    };

    return (
        <div>
            {people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}
            <button
                type='button'
                className='btn'
                style={{ marginTop: "2rem" }}
                onClick={clearAllItems}
            >
                Remove All
            </button>
        </div>
    );
};

export default UseStateArray;
```

### useState With Object

```js
import Starter from "./tutorial/01-useState/starter/04-useState-object.jsx";
```

#### Setup Challenge :

-   setup three state values
    -   name - string
    -   age - number
    -   hobby - string
-   render these in the browser
-   create a button
    -   setup a function
        -   update all the three state values
-   Once the user clicks the button, a new person is displayed in the browser

#### Without Object

```js
import { useState } from "react";

const UseStateObject = () => {
    const [name, setName] = useState("Peter");
    const [age, setAge] = useState(26);
    const [hobby, setHobby] = useState("Read Books");

    const handleClick = () => {
        setName("John");
        setAge(30);
        setHobby("Play Games");
    };

    return (
        <div>
            <h4>{name}</h4>
            <h4>{age}</h4>
            <h4>Enjoys: {hobby}</h4>
            <button type='button' className='btn' onClick={handleClick}>
                Show John
            </button>
        </div>
    );
};

export default UseStateObject;
```

#### Automatic Batching

-   In React, "batching" refers to the process of grouping multiple state updates into a single update. This can be useful in certain cases because it allows React to optimize the rendering of your components by minimizing the number of DOM updates that it has to perform.

-   By default, React uses a technique called "auto-batching" to group state updates that occur within the same event loop into a single update. This means that if you call the state update function multiple times in a short period of time, React will only perform a single re-render for all of the updates.

-   React 18 ensures that state updates invoked from any location will be batched by default. This will batch state updates, including native event handlers, asynchronous operations, timeouts, and intervals.

#### Switch To Object

```js
import { useState } from "react";

const UseStateObject = () => {
    const [person, setPerson] = useState({
        name: "Peter",
        age: 26,
        hobby: "Read Books",
    });

    const handleClick = () => {
        setPerson({
            name: "John",
            age: 30,
            hobby: "Plays Games",
        });

        // setPerson({ ...person, name: "Kush" });
        // change only one property, and preserve the rest
    };

    return (
        <div>
            <h4>{person.name}</h4>
            <h4>{person.age}</h4>
            <h4>Enjoys: {person.hobby}</h4>
            <button type='button' className='btn' onClick={handleClick}>
                Show John
            </button>
        </div>
    );
};

export default UseStateObject;
```

### Set Function "Gotcha"

```js
import Starter from "./tutorial/01-useState/starter/05-useState-gotcha.jsx";
```

#### Setup Challenge :

-   setup a state value and a button
-   add functionality to increase value by 1
-   log the state value, right after setFunction

-   Keep in mind that the state update function setState does not immediately mutate the state. Instead, it schedules an update to the state and tells React that it needs to re-render the component. The actual state update will be performed as part of the next rendering cycle. Be mindful when you need to set state value based on a different state value.

#### Example

```js
import { useState } from "react";

const UseStateGotcha = () => {
    const [value, setValue] = useState(0);

    const handleClick = () => {
        setValue(value + 1);
        console.log(value);
        // be careful the value is not updated synchronously!
        // so if you have any functionality that relies on the latest value, it will be wrong!
    };

    return (
        <div>
            <h1>{value}</h1>
            <button type='submit' className='btn' onClick={handleClick}>
                Increase
            </button>
        </div>
    );
};

export default UseStateGotcha;
```

-   Instead of passing the new state value, we can pass in a function inside the state value.
-   The parameter of the function, contains the current value of the state. It is provided by React by default.
-   If you want to update the state immediately and synchronously, you can pass a function to setState that receives the previous state as an argument and returns the new state.
-   The function MUST return a value, or it fails.

#### Example

```js
setState((prevState) => {
    return { ...prevState, value: newValue };
});
```

-   This can be useful if you need to update the state based on the previous state, or if you need to update the state synchronously.

```js
import { useState } from "react";

const UseStateGotcha = () => {
    const [value, setValue] = useState(0);

    const handleClick = () => {
        setValue((currentState) => {
            const newState = currentState + 1;
            return newState;
        });
    };

    return (
        <div>
            <h1>{value}</h1>
            <button type='submit' className='btn' onClick={handleClick}>
                Increase
            </button>
        </div>
    );
};

export default UseStateGotcha;
```

#### setTimeout Example

-   Invoke the functionality after some time
-   Everytime we will click the button, setTimeOut function will be invoked, and the value will be updated after 3 seconds
-   Inside the callback function, when we invoke setValue function, we are not grabbing the latest value of the state
-   Instead, we are grabbing the value that is present inside the variable within those 3 seconds

```js
const handleClick = () => {
    setTimeout(() => {
        console.log(value);
        setValue(value + 1);
        // we are not grabbing the latest value
    }, 3000);
};
```

-   The fix is to use functional approach to update the state, to grab the latest value everytime we invoke the function after clicking the button
-   the "currentState" parameter provides the latest value of the state, rather than grabbing it from the value variable, which is not updated synchronously

#### Code

```js
const handleClick = () => {
    setTimeout(() => {
        setValue((currentValue) => {
            return currentValue + 1;
            // grab the latest value of the state
        });
    }, 3000);
};
```

## The Need For useEffect

```js
import Starter from "./tutorial/02-useEffect/starter/01-code-example.jsx";
```

#### Some Basic Questions?

-   How does the code execute inside a component?
-   In the below example, the `sayHello()` function is invoked after every re-render/initial render
-   Therefore, the function also compiles and executes everytime the state is updated, as it triggers a re-render
-   Thus, we need to take care of infinite loops inside these functions!

#### Example

```js
import { useState } from "react";

const CodeExample = () => {
    const [value, setValue] = useState(0);

    const sayHello = () => {
        console.log("hello there!");
    };
    sayHello();

    return (
        <div>
            <h1>value : {value}</h1>
            <button className='btn' onClick={() => setValue(value + 1)}>
                Click Me!
            </button>
        </div>
    );
};
export default CodeExample;
```

-   The problem with the code starts, when we update the state, as it triggers a re-render

```js
const [value, setValue] = useState(0);

const sayHello = () => {
    // be careful, you will have infinite loop
    console.log("hello there");
    setValue(value + 1);
};
sayHello();
```

#### Execution

-   initial render - we setup state value and invoke the function sayHello
-   in the sayHello function when we update the state, we trigger a re-render

-   re-render - update the state value and invoke sayHello function again
-   in the sayHello function when we update the state, we trigger a re-render

-   repeat
-   repeat
-   repeat

-   **this causes an infinite loop to occur, which breaks our application**

## useEffect Basics

```js
import Starter from "./tutorial/02-useEffect/starter/02-useEffect-basics.jsx";
```

#### Definition

-   useEffect helps us to run code "conditionally" in our React application.
-   We will be able to choose, when we want to run certain code inside a component.
-   useEffect is a hook in React that allows you to perform side effects in function components. There is no need for urban dictionary - basically any work outside of the component. Some examples of side effects are: subscriptions, fetching data, directly updating the DOM, event listeners, timers, etc.

#### useEffect Hook

-   accepts two arguments
-   first argument - callback function
-   second argument - dependency array (optional)
-   callback function cannot return a promise (so we cannot make it async)
-   if dependency array empty [], the callback function runs only on the initial render
-   by default, the code inside the callback function runs after every render (initial and re-render)

#### Example

```js
import { useState, useEffect } from "react";

const CodeExample = () => {
    const [value, setValue] = useState(0);

    const sayHello = () => {
        console.log("hello there");
    };
    sayHello();

    useEffect(() => {
        console.log("hello from useEffect!");
    }, []);

    return (
        <div>
            <h1>value : {value}</h1>
            <button className='btn' onClick={() => setValue(value + 1)}>
                Click Me!
            </button>
        </div>
    );
};
export default CodeExample;
```

-   If we have just a plain function, and we invoke it, it will execute after every render (initial render and re-render due to state change).
-   However, with useEffect, we can choose to run it after every render, or just once, with the help of the dependency array argument (execute only after initial render or after every render).

#### Async Functions

```js
// WRONG, cannot return a promise!
useEffect(async () => {
    console.log("hello from useEffect!");
}, []);
```

```js
// CORRECT, we can set up inside, and invoke it!
useEffect(() => {
    const someFunc = async () => {
        await fetch;
    };
    someFunc;
}, []);
```

### Promises

-   [Callback Hell - JavaScript Nuggets](https://www.youtube.com/watch?v=bx9xYPt2tdc&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=14)
-   Main reason of using promises is to avoid callback hell.
-   Promises allows us to write async code in a synchronous fashion.
-   Code that completes execution at different times, to run in an ordered fashion (sequence-wise)

##### Example

-   change `<h1>` to red after '3 seconds'.
-   change `<h2>` to blue after '5 seconds'.
-   change `<h3>` to green after '2 seconds'.
-   But all of these "async" changes must be made in synchronous (orderly fashion).
-   which means first update `<h1>`, then update `<h2>`, and after that update `<h3>`.

##### Real-Life Examples

-   [JavaScript Promises - JavaScript Nuggets](https://www.youtube.com/watch?v=IBjmTlShf6U&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=15)
-   Promise is an object that returns a value, which you hope to receive in the future but not now.
-   Example: You place an order at a restaurant, and you get a recepit which is similar to a promise. The restaurant returns you the plate of food after some time, or the restaurant might deny your order because of some problem. Therefore the receipt acts as the promise in this case.
-   Promises are used with HTTP Requests.
-   You set up a request, and the server takes some time to return the response.
-   You either get the required data from the response, or you might get an error.

#### Code

```js
// how to create a promise?
// call a constructor named "Promise", and pass a callback function inside the constructor.
// the constructor contains two arguments, which are functions themselves.

// promises can be in either of these 3 states - Pending, Rejected, Fulfilled.
// the starting state is always pending, which goes to either rejected or fulfilled.

// successful promise completion is indicated by resolve() function call.
// unsuccessful promise completion is indicated by reject() function call.
// when a promise rejects, the control jumps to the closest rejection handler (.catch).
// both of these functions are used to pass data to our application, depending on the state of the promise.

// we can set up conditions inside the promise's callback function, to either resolve/fulfill the promise to get the data, or reject/unfulfill the promise to throw an error.

const promise = new Promise((resolve, reject) => {
    // resolve("data received");
    // reject("there was an error");
});
console.log(promise);

// how to access the values, provided by resolve/reject methods?
// need to use .then method for resolve(), and .catch method for reject()

promise.then((data) => {
    // the argument contains the data!
    console.log(data);
});
promise.catch((err) => {
    // the argument contains the data!
    console.log(err);
});
```

### Async / Await

-   Allows us to write async code, in synchronous fashion.
-   We can use await to easily grab the data from a settled promise, instead of using a chain of .then() and .catch()!

#### Properties

-   Await will always wait until the promise is settled.
-   Async function ALWAYS ALWAYS ALWAYS returns a promise.
-   We can only use await, if we have async in front of the function.

#### Code

```js
const exampleOne = async () => {
    return "hello there";
};
// ALWAYS returns a promise!

async function exampleTwo() {
    return "hello there";
}
// ALWAYS returns a promise!

console.log(exampleOne());
console.log(exampleTwo());

// CODE EXAMPLE
const returnData = async () => {
    return "hello there";
};

const displayData = async () => {
    // grab the result of the settled promise!
    const result = await returnData();
    console.log(result);
};
displayData();
```

-   Await function keeps on waiting till the promise is fulfilled, if it is not fulfilled it throws an error.
-   When a promise rejects, the control jumps to the closest rejection handler (catch block).
-   Therefore we must handle the error using a try-catch block, or the application breaks.

```js
const users = [
    { id: 1, name: "john" },
    { id: 2, name: "susan" },
    { id: 3, name: "anna" },
];

const articles = [
    { userId: 1, articles: ["one", "two", "three"] },
    { userId: 2, articles: ["four", "five"] },
    { userId: 3, articles: ["six", "seven", "eight", "nine"] },
];

// USE AWAIT / ASYNC
const getData = async () => {
    try {
        const user = await getUser("john");
        const articles = await getArticles(user.id);
        console.log(articles);
    } catch (error) {
        console.log(error);
    }
};
getData();

// getUser("susan")
//     .then((user) => getArticles(user.id))
//     .then((articles) => console.log(articles))
//     .catch((err) => console.log(err));

function getUser(name) {
    return new Promise((resolve, reject) => {
        const user = users.find((user) => user.name === name);

        if (user) {
            return resolve(user);
        } else {
            reject(`No such user with name : ${name}`);
        }
    });
}

function getArticles(userId) {
    return new Promise((resolve, reject) => {
        const userArticles = articles.find((user) => user.userId === userId);

        if (userArticles) {
            return resolve(userArticles.articles);
        } else {
            reject(`Wrong ID`);
        }
    });
}
```

### Multiple Effects

```js
import Starter from "./tutorial/02-useEffect/starter/03-multiple-effects.jsx";
```

-   If we pass an empty array, the function runs only after the initial render.
-   However, if we pass in the state value, it will also run after the value of the specified state is changed.
-   We can specify multiple values in the dependency array, and everytime any of the value inside this array changes, the callback function is invoked.

#### Example

```js
useEffect(() => {
    console.log("hello from first useEffect");
}, []);
useEffect(() => {
    console.log("hello from second useEffect");
}, []);
```

#### Example

```js
import { useState, useEffect } from "react";

const MultipleEffects = () => {
    const [value, setValue] = useState(0);
    const [secondValue, setSecondValue] = useState(0);

    // code runs on initial render, and when "value" is changed!
    useEffect(() => {
        console.log("hello from first useEffect");
    }, [value]);

    // code runs on initial render, and when "secondValue" is changed!
    useEffect(() => {
        console.log("hello from second useEffect");
    }, [secondValue]);

    return (
        <div>
            <h1>Value : {value}</h1>
            <button className='btn' onClick={() => setValue(value + 1)}>
                Value
            </button>
            <h1>Second Value : {secondValue}</h1>
            <button
                className='btn'
                onClick={() => setSecondValue(secondValue + 1)}
            >
                Second Value
            </button>
        </div>
    );
};
export default MultipleEffects;
```

### Fetch Data

```js
import Starter from "./tutorial/02-useEffect/starter/04-fetch-data.jsx";
```

-   [Javascript Nuggets - Fetch API](https://www.youtube.com/watch?v=C_VIKzfpRrg&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=18&t=343s)
-   Fetch some GitHub users, and display them on the screen.
-   Later in the course we will use axios, for more complex projects.

#### Fetch API

-   Browser API, for HTTP requests.
-   Fetch ALWAYS ALWAYS returns a promise.
-   Provided by the browser, don't need to import anything.
-   Performs GET request, just like the browser. Reads data from the server.

```js
// below url returns an array of objects
const url = "https://www.course-api.com/react-tours-project";

// fetch returns a promise
console.log(fetch(url));

fetch(url)
    .then((response) => console.log(response)) // not in JSON format!
    .catch((err) => console.log(err));

// need to use json() function to convert the response to a json object.
// the json() function returns a promise, which contains the object.
fetch(url)
    .then((response) => response.json()) // returns a promise!
    .then((data) => console.log(data)) // in JSON format!
    .catch((err) => console.log(err));

const getTours = async () => {
    try {
        const response = await fetch(url);
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.log(error);
    }
};
getTours();
```

#### Setup Challenge :

-   setup state variable "users"
    -   default value = [ ]
-   setup useEffect
    -   make sure it runs only on the initial render
    -   in the callback, create a function which performs fetch functionality
-   iterate over the list and display the image, username and also the link

#### Code

```js
import { useState, useEffect } from "react";

const url = "https://api.github.com/users";

const FetchData = () => {
    const [users, setUsers] = useState([]);

    useEffect(() => {
        const getData = async () => {
            try {
                const response = await fetch(url);
                const data = await response.json();
                setUsers(data);
            } catch (error) {
                console.log(error);
            }
        };
        getData();
    }, []);

    return (
        <>
            <h3>Github Users!</h3>
            <ul className='users'>
                {users.map((user) => {
                    const { id, login, avatar_url, html_url } = user;
                    return (
                        <li key={id}>
                            <img src={avatar_url} alt='N/A' />
                            <div>
                                <h5>{login}</h5>
                                <a href={html_url}>Profile</a>
                            </div>
                        </li>
                    );
                })}
            </ul>
        </>
    );
};
export default FetchData;
```

### Cleanup Function

**Study After Conditional Rendering!**

```js
import Starter from "./tutorial/02-useEffect/starter/05-cleanup-function.jsx";
```

#### Setup Challenge :

-   create a state value
-   in jsx, return button which toggles the state value
-   based on some condition return a second component (simple return)
-   inside second component, create useEffect and run it only on initial render

#### Code

```js
import { useState, useEffect } from "react";

const CleanupFunction = () => {
    const [toggle, setToggle] = useState(true);

    return (
        <div>
            <button className='btn' onClick={() => setToggle(!toggle)}>
                Toggle Component
            </button>
            {toggle && <RandomComponent />}
        </div>
    );
};

const RandomComponent = () => {
    useEffect(() => {
        console.log("hmm, interesting");
    }, []);
    return <h1>Hello There!</h1>;
};

export default CleanupFunction;
```

-   In the above code, the useEffect function executes everytime we toggle the component.
-   This means that everytime we toggle the component, it mounts and unmounts repeatedly.
-   Therefore, the useEffect function also runs multiple times.
-   We need to set-up a cleanup function in these cases, when the component is being displayed conditionally, and keeps on repeatedly being mounted and unmounted, leading to multiple execution of useEffect function.

#### Setup :

-   `setInterval()` function is used to repeat a block of code at regular intervals.
-   `setInterval()` function returns an id.

-   When we toggle the component, the setInterval() function keeps on running even after the component is unmounted, as we do not terminate it's invocation.
-   This can lead to serious issues, and we need a cleanup function to terminate this.

-   For cleanup function, return a function in the useEffect callback function, and whatever is inside the returned function, will be invoked.
-   The cleanup functions, are executed after the re-render (when the component unmounts).
-   `clearInterval(id)` is a special method used to terminate the `setInterval()` method.

#### Code

```js
import { useState, useEffect } from "react";

const CleanupFunction = () => {
    const [toggle, setToggle] = useState(true);

    return (
        <div>
            <button className='btn' onClick={() => setToggle(!toggle)}>
                Toggle Component
            </button>
            {toggle && <RandomComponent />}
        </div>
    );
};

const RandomComponent = () => {
    useEffect(() => {
        console.log("hmm, interesting");

        // setInterval returns an id!
        const intId = setInterval(() => {
            // keeps on running after unmounting as well!
            console.log("hello from interval");
        }, 1000);

        // cleanup function!
        return () => {
            clearInterval(intId);
        };
    }, []);
    return <h1>Hello There!</h1>;
};

export default CleanupFunction;
```

#### Example

```js
const RandomComponent = () => {
    useEffect(() => {
        const someFunc = () => {
            // some logic is defined!
        };
        // event keeps getting added after every re-render!
        window.addEventListener("scroll", someFunc);

        return () => {
            // therefore, we need to remove the event when we unmount!
            window.removeEventListener("scroll", someFunc);
        };
    }, []);
    return <h1>Hello There!</h1>;
};
```

## Multiple Returns

### Basics

```js
import Starter from "./tutorial/03-conditional-rendering/starter/01-multiple-returns-basics.jsx";
```

-   Control what is displayed in the browser, based on some condition.
-   Multiple returns are same in React as in Vanilla JS.

#### Vanilla JS

```js
const sayHello = (name) => {
    if (name) {
        return `Hello, ${name}`;
        // exit the function, skip rest of the code!
    }
    // if name is not provided, return below value!
    return "Hello, there";
};

const firstResp = sayHello("john");
console.log(firstResp); // Hello, john
const secondResp = sayHello();
console.log(secondResp); // Hello, there
```

-   If no explicit return, by default the function returns "undefined".

#### Example

```js
import { useEffect, useState } from "react";

const MultipleReturnsBasics = () => {
    const [isLoading, setIsLoading] = useState(true);
    // naming convention of boolean values "isSomething"!

    useEffect(() => {
        setTimeout(() => {
            setIsLoading(false);
            // done fetching data!
        }, 3000);
    }, []);

    // set-up multiple returns!
    if (isLoading) {
        return <h1>Loading...</h1>;
    }
    return <h2>Multiple Returns Basics</h2>;
};
export default MultipleReturnsBasics;
```

### Fetch Data

```js
import Starter from "./tutorial/03-conditional-rendering/starter/02-multiple-returns-fetch-data.jsx";
```

#### Setup Challenge :

-   create a state variable, default value = null
-   fetch data from the url, and log the data

#### Code

```js
import { useEffect, useState } from "react";

const url = "https://api.github.com/users/QuincyLarson";

const MultipleReturnsFetchData = () => {
    const [user, setUser] = useState(null);

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const response = await fetch(url);
                const user = await response.json();
                console.log(user);
            } catch (error) {
                console.log(error);
            }
        };
        fetchUser();
    }, []);

    return <h2>Fetch Data</h2>;
};
export default MultipleReturnsFetchData;
```

#### Data Fetching :

-   Usually, we have three options when fetching data:
    -   **Loading** - waiting for data to arrive (display loading state)
    -   **Error** - there was an error (display error message)
    -   **Success** - received data (display data)

#### Code

```js
import { useEffect, useState } from "react";

const url = "https://api.github.com/users/QuincyLarson";

const MultipleReturnsFetchData = () => {
    const [isLoading, setIsLoading] = useState(true); // initially true, as we always load data first!
    const [isError, setIsError] = useState(false); // initially false, we assume no error occurs!
    const [user, setUser] = useState(null);

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const response = await fetch(url);
                const user = await response.json();
                setUser(user);
            } catch (error) {
                setIsError(true);
                // go-to the error block return!
            }
            setIsLoading(false);
            // loading-block is complete in both cases!
        };
        fetchUser();
    }, []);

    if (isLoading) {
        return <h1>Loading...</h1>;
    }
    // after loading is complete, either we get an error, or the data!

    if (isError) {
        return <h1>There Was An Error!</h1>;
    }
    return (
        <div>
            <img
                style={{ width: "150px", borderRadius: "25px" }}
                src={user.avatar_url}
                alt={user.name}
            />
            <h2>{user.name}</h2>
            <h4>works at {user.company}</h4>
            <p>{user.bio}</p>
        </div>
    );
};
export default MultipleReturnsFetchData;
```

#### Fetch Errors "Gotcha"

-   Unlike Axios, by default, the fetch() API does not consider HTTP status codes in the 4xx or 5xx range to be errors.
-   Instead, it considers these status codes to be successfully completed.
-   To catch these 404 errors, we need to look for the "ok" property in the "response" header.

#### Code

```js
useEffect(() => {
    const fetchUser = async () => {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                setIsError(true);
                setIsLoading(false);
                return;
                // exit the function to throw an error!
            }
            const user = await response.json();
            setUser(user);
        } catch (error) {
            setIsError(true);
            // go-to the error block return!
        }
        setIsLoading(false);
        // loading-block is complete in both cases!
    };
    fetchUser();
}, []);
```

### Order Matters

```js
import Starter from "./tutorial/03-conditional-rendering/starter/02-multiple-returns-fetch-data.jsx";
```

#### Setup Challenge :

-   destructure the properties, and use inside the return.
-   you might or might not encounter the bug, after destructuring the properties.

```js
import { useEffect, useState } from "react";

const url = "https://api.github.com/users/QuincyLarson";

const MultipleReturnsFetchData = () => {
    const [isLoading, setIsLoading] = useState(true);
    const [isError, setIsError] = useState(false);
    const [user, setUser] = useState(null);

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    setIsError(true);
                    setIsLoading(false);
                    return;
                }
                const user = await response.json();
                setUser(user);
            } catch (error) {
                setIsError(true);
            }
            setIsLoading(false);
        };
        fetchUser();
    }, []);

    if (isLoading) {
        return <h1>Loading...</h1>;
    }
    if (isError) {
        return <h1>There Was An Error!</h1>;
    }

    const { avatar_url, name, company, bio } = user;
    // destructuring works in this case!
    return (
        <div>
            <img
                style={{ width: "100px", borderRadius: "25px" }}
                src={avatar_url}
                alt={name}
            />
            <h2>{name}</h2>
            <h4>works at {company}</h4>
            <p>{bio}</p>
        </div>
    );
};
export default MultipleReturnsFetchData;
```

-   We only have the user object, after the useEffect function is complete, which occurs when the isLoading state become false. Therefore cannot destructure before that.
-   Also if we hit the error block in the useEffect function, the user object still remains null, and therefore, we cannot destructure it.
-   Therefore, we must destructure the properties after all of the conditional returns only.

```js
import { useEffect, useState } from "react";

const url = "https://api.github.com/users/QuincyLarson";

const MultipleReturnsFetchData = () => {
    const [isLoading, setIsLoading] = useState(true);
    const [isError, setIsError] = useState(false);
    const [user, setUser] = useState(null);

    // const { avatar_url, name, company, bio } = user;
    // CANNOT DESTRUCTURE HERE! USER NULL!

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    setIsError(true);
                    setIsLoading(false);
                    return;
                }
                const user = await response.json();
                setUser(user);
            } catch (error) {
                setIsError(true);
            }
            setIsLoading(false);
        };
        fetchUser();
    }, []);

    // const { avatar_url, name, company, bio } = user;
    // CANNOT DESTRUCTURE HERE! USER NULL!

    if (isLoading) {
        return <h1>Loading...</h1>;
        // user state still remains null!
    }
    if (isError) {
        return <h1>There Was An Error!</h1>;
        // user state still remains null!
    }

    const { avatar_url, name, company, bio } = user;
    // CAN DESTRUCTURE ONLY AFTER THE CONDITIONS!
    return (
        <div>
            <img
                style={{ width: "100px", borderRadius: "25px" }}
                src={avatar_url}
                alt={name}
            />
            <h2>{name}</h2>
            <h4>works at {company}</h4>
            <p>{bio}</p>
        </div>
    );
};
export default MultipleReturnsFetchData;
```

#### Vanilla JS

```js
const someObject = {
    name: "John",
};

// this is OK!
someObject.name; // returns 'jo koy'!
someObject.propertyThatDoesNotExist; // returns undefined!

// this is not OK, throws error!
const randomValue = null;
randomValue.name;
```

### Hook Rules

```js
import Starter from "./tutorial/03-conditional-rendering/starter/03-hooks-rule.jsx";
```

#### Conditional Hooks

-   Cannot call hooks conditionally (inside if conditions).
-   Similarily, cannot place useEffect after multiple returns, as the code might stop execution before the useEffect hook is called.

#### Example

```js
import { useState, useEffect } from "react";

const Example = () => {
    const [condition, setCondition] = useState(true);
    if (condition) {
        const [state, setState] = useState(false);
        // cannot call hooks conditonally!
    }

    if (condition) {
        return <h2>Hello There</h2>;
    }
    useEffect(() => {
        console.log("hello there");
        // this will also fail, multiple returns!
    }, []);

    return (
        <div>
            <h1>Example</h1>
        </div>
    );
};

export default Example;
```

#### Truthy and Falsy Values

-   In JavaScript, a value is considered "truthy" if it is evaluated to true when used in a boolean context. A value is considered "falsy" if it is evaluated to false when used in a boolean context.

-   Here is a list of values that are considered falsy in JavaScript:

    -   false
    -   0 (zero)
    -   "" (empty string)
    -   null
    -   undefined
    -   NaN (Not a Number)

-   All other values, including objects and arrays, are considered truthy.

#### Short Circuit Evaluation

-   In JavaScript, short-circuit evaluation is a technique that allows you to use logical operators (such as && and ||) to perform conditional evaluations in a concise way.

-   The && operator (logical AND) returns the first operand if it is "falsy", or the second operand if the first operand is "truthy", and the second operand is "falsy".

##### Example

```js
const x = 0;
const y = 1;

console.log(x && y); // Output: 0 (the first operand is falsy, so it is returned)
console.log(y && x); // Output: 0 (the second operand is falsy, so it is returned)
```

-   The || operator (logical OR) returns the first operand if it is "truthy", or the second operand if the first operand is "falsy", and the second is "truthy".

##### Example

```js
const x = 0;
const y = 1;

console.log(y || x); // Output: 1 (the first operand is truthy, so it is returned)
console.log(x || y); // Output: 1 (the second operand is truthy, so it is returned)
```

-   Short-circuit evaluation can be useful in cases where you want to perform a certain action only if a certain condition is met, or you want to return a default value if a certain condition is not met.

##### Example

```js
function displayName(name) {
    return name || "Anonymous";
}

console.log(displayName("Pizza")); // Output: "Pizza"
console.log(displayName()); // Output: "Anonymous"
```

-   In this example, the displayName() function returns the name property of the user object if it exists, or "Anonymous" if the name property is not present. This is done using the || operator and short-circuit evaluation.

### Short Circuit Evaluation React - Basics

```js
import Starter from "./tutorial/03-conditional-rendering/starter/04-short-circuit-overview.jsx";
```

#### Setup Challenge :

-   create two state values.
-   one "falsy" and second "truthy".
-   setup both conditions for each operator in JSX - hint is to use { }.
    -   `||` OR
    -   `&&` AND

```js
import { useState } from "react";

const ShortCircuitOverview = () => {
    const [text, setText] = useState(""); // falsy
    const [name, setName] = useState("susan"); // truthy

    const codeExample = text || "hello world";

    return (
        <div>
            <h4>Falsy AND : {text && "hello world"}</h4>
            <h4>Truthy AND : {name && "hello world"}</h4>
            <h4>Falsy OR : {text || "hello world"}</h4>
            <h4>Truthy OR : {name || "hello world"}</h4>
            {codeExample}
        </div>
    );
};
export default ShortCircuitOverview;
```

### Short Circuit Evaluation in React - Common Approaches

```js
import Starter from "./tutorial/03-conditional-rendering/starter/05-short-circuit-examples.jsx";
```

-   We cannot use if else statements inside JSX, therefore need to use logical operators.
-   OR operator is used to set a default value, if the value does not exist.
-   AND operator is used to control what is displayed on the screen.
-   We can also use `!` (not) operator.

#### Example

```js
import { useState } from "react";

const ShortCircuitExamples = () => {
    const [text, setText] = useState("");
    const [name, setName] = useState("susan");
    const [user, setUser] = useState({ name: "John" });
    const [isEditing, setIsEditing] = useState(false);

    return (
        <div>
            <h2>{text || "default-value"}</h2>

            {text && (
                <div>
                    <h2>Example</h2>
                    <p>Return this div, if text exists</p>
                </div>
            )}
            {/* {!text && (
                <div>
                    <h2>Example</h2>
                </div>
            )} */}
        </div>
    );
};

export default ShortCircuitExamples;
```

-   Below is an example to show the component, if the user state value exists (if user value is truthy!).
-   Real life use case is that we fetch a user from the database, and if the user exists, the component is displayed, else the component is not displayed if the user does not exist and null value is returned from the database.

#### Example

```js
import { useState } from "react";

const ShortCircuitExamples = () => {
    const [text, setText] = useState("");
    const [name, setName] = useState("susan");
    const [user, setUser] = useState({ name: "John" });
    const [isEditing, setIsEditing] = useState(false);

    return <div>{user && <SomeComponent name={user.name} />}</div>;
};

const SomeComponent = ({ name }) => {
    return (
        <div>
            <h2>Example</h2>
            <h2>{name}</h2>
        </div>
    );
};
export default ShortCircuitExamples;
```

### Ternary Operator

-   In JavaScript, the ternary operator is a way to concisely express a simple conditional statement. It is often called the "conditional operator" or the "ternary conditional operator".

-   Here is the basic syntax for using the ternary operator:

```js
condition ? expression1 : expression2;
```

-   If condition is truthy, the operator will return expression1. If condition is falsy, it will return expression2.

-   The operator always RETURNS one of the two values.

#### Example

```js
import { useState } from "react";

const ShortCircuitExamples = () => {
    const [text, setText] = useState("");
    const [name, setName] = useState("susan");
    const [user, setUser] = useState({ name: "John" });
    const [isEditing, setIsEditing] = useState(false);

    return (
        <div>
            <h2>Ternary Operator</h2>
            <button className='btn'>{isEditing ? "edit" : "add"}</button>
        </div>
    );
};

export default ShortCircuitExamples;
```

#### Example - Return Different Elements

```js
import { useState } from "react";

const ShortCircuitExamples = () => {
    const [text, setText] = useState("");
    const [name, setName] = useState("susan");
    const [user, setUser] = useState({ name: "John" });
    const [isEditing, setIsEditing] = useState(false);

    return (
        <div>
            <h2>Ternary Operator</h2>
            {user ? (
                <div>
                    <h2>Hello there user {user.name}!</h2>
                </div>
            ) : (
                <div>
                    <h2>Please sign in!</h2>
                </div>
            )}
        </div>
    );
};

export default ShortCircuitExamples;
```

### Toggle Challenge

```js
import Starter from "./tutorial/03-conditional-rendering/starter/06-toggle-challenge.jsx";
```

#### Initial Setup :

-   create a state value (boolean).
-   return a button and a component/element.
-   when the user clicks the button:
    -   toggle the state value.
    -   conditionally render component/element.

#### Code

```js
import { useState } from "react";

const ToggleChallenge = () => {
    const [showAlert, setShowAlert] = useState(false);

    const toggleAlert = () => {
        setShowAlert(!showAlert);
    };

    return (
        <div>
            <button className='btn' onClick={toggleAlert}>
                Toggle
            </button>
            {showAlert && <Alert />}
        </div>
    );
};

const Alert = () => {
    return <div className='alert alert-danger'>Hello World!</div>;
};

export default ToggleChallenge;
```

### User Challenge

```js
import Starter from "./tutorial/03-conditional-rendering/starter/07-user-challenge.jsx";
```

-   create state value

    -   default value = null

-   create two functions

    -   login - sets user equal to object with name property
    -   logout - sets user equal to null

-   in jsx use ? to display the two different setups
    -   h4 with "hello there, user name" and logout button
    -   h4 with "please login " and login button

#### Code

```js
import { useState } from "react";

const UserChallenge = () => {
    const [user, setUser] = useState(null);

    const login = () => {
        setUser({ name: "Kush" });
    };
    const logout = () => {
        setUser(null);
    };

    return (
        <div>
            {user ? (
                <Login name={user.name} logout={logout} />
            ) : (
                <Logout login={login} />
            )}
        </div>
    );
};

const Login = ({ name, logout }) => {
    return (
        <div>
            <h4>Hello There! {name}</h4>
            <button className='btn' onClick={() => logout()}>
                Logout
            </button>
        </div>
    );
};
const Logout = ({ login }) => {
    return (
        <div>
            <h4>Please Sign In!</h4>
            <button className='btn' onClick={() => login()}>
                Login
            </button>
        </div>
    );
};

export default UserChallenge;
```

## Project Structure - Default Export

#### Option #1:

-   create "components" and "screens" folders.

    -   `/components/componentName.jsx`
    -   `/screens/componentName.jsx`

#### Option #2:

-   Keep all the files associated with a component inside one folder.
-   create "Navbar" folder for "Navbar" Component.

    -   setup `Navbar.jsx` (component)
    -   setup `Navbar.css` (styles)

-   import the component in App.jsx

```js
// problem is we need to write Navbar/Navbar twice!
import "./tutorial/04-project-structure/final/Navbar/Navbar";
```

#### Solution

-   create `index.js`
-   "index" files act as the default entry point, if no file is specified in the folder.
-   `import "./tutorial/04-project-structure/final/Navbar";`, automatically redirects to `index.js` inside the "Navbar" folder, if no file is specified.

-   but, the new problem is that, we will have a lot of index.js for every component folder, which becomes difficult to distinguish and navigate.
-   the solution is to export the Navbar component, using the `index.js` file.

##### index.js

```js
export { default } from "./Navbar";
// import the navbar component and export it!
```

## Project Structure - Named Exports

-   create "pages" folder.

-   setup two components "Home.jsx" and "About.jsx".

-   import both of the components in "App.jsx" to display them.

```js
import Home from "pathToFolder/Pages/Home";
import About from "pathToFolder/Pages/About";
```

-   If we have 20 components, will have to write 20 lines of imports.

#### Solution

-   create "index.jsx", and import all of the components in one place.

##### index.jsx

```js
import Home from "./Home";
import About from "./About";

export { Home, About };
```

##### App.jsx

```js
import { Home, About } from "pathToFolder/Pages";
```

## Project Structure - Export Group

-   create "Example" folder.

-   setup two components inside the folder, and create "index.jsx" file

-   in index.jsx setup a new component and render/import both of the components inside the new component.

-   import/render "index.jsx" in "App.jsx" to display the group of components.

## Project Structure - Extra Extensions

-   **Code Spell Checker** - works well with code and documents.

-   **Glean** - easily extract jsx into a new component.

## Leverage Javascript

```js
import Example from "./tutorial/05-leverage-javascript/final/List";
```

-   [Javascript Nuggets - Optional Chaining](https://www.youtube.com/watch?v=PuEGrylM1x8&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=12&t=254s)

#### Code

```js
// more straightforward syntax, for working with deeply-nested properties.
// used when some properties are not present in all of the objects.

const people = [
    {
        name: "bob",
        location: { street: "123 main street", timezone: { offset: "+7:00" } },
    },
    { name: "peter", location: { street: "123 Pine street" } },
    {
        name: "susan",
        location: { street: "123 Apple street", timezone: { offset: "+9:00" } },
    },
];

people.forEach((person) => {
    console.log(person.name);
    console.log(person.location);

    // console.log(person.location.timezone.offset);
    // throws error, as all of the objects do not have this property!
});

people.forEach((person) => {
    // console.log(
    //     person.location && person.location.timezone && person.location.offset
    // );

    // ALTERNATIVE
    console.log(person?.location?.timezone?.offset);
    // check for person, if present check for location, and so on!
    // return undefined if the property is not present, instead of an error!
});
```

#### Setup Challenge :

-   analyze people array in data.js

-   create a new component, List.jsx component
-   in List.jsx import and iterate over the people array
-   render the name property in List.jsx component

-   now, set-up Person.jsx component
-   in this component, render the name, nickName, image

-   Yes, you will encounter a bug.

```js
import List from "./tutorial/05-leverage-javascript/final/List";

function App() {
    return (
        <div className='container'>
            <List />
        </div>
    );
}

export default App;
```

#### App.jsx

```js
import List from "./tutorial/05-leverage-javascript/final/List";

function App() {
    return (
        <div className='container'>
            <List />
        </div>
    );
}

export default App;
```

#### List.jsx

```js
import { people } from "../../../data";
import { Person } from "./Person";

const List = () => {
    return (
        <div>
            {people.map((person) => {
                return <Person {...person} key={person.id} />;
            })}
        </div>
    );
};
export default List;
```

#### Person.jsx

```js
import React from "react";

export const Person = ({ name, nickName, image }) => {
    const img = image[0].small.url;
    // throws an error, as property does not exist for all objects!

    return (
        <div>
            <img src={img} alt={name} style={{ width: "50px" }} />
            <h4>{name}</h4>
            <p>Nickname : {nickName}</p>
        </div>
    );
};
```

### Default Values - Vanilla JS

-   In JavaScript, when defining a function, you can specify default values for its parameters. This means that if a caller of the function does not provide a value for a particular parameter, the default value will be used instead. Default parameters are defined by assigning a value to the parameter in the function definition.

-   For example, consider the following function, which takes two parameters, x and y, and returns their sum:

```js
function add(x, y) {
    return x + y;
}
```

-   If we call this function with only one argument, it will return NaN because y is undefined.

-   We can set default values for x, y as:

```js
function add(x = 0, y = 0) {
    return x + y;
}
```

-   Now, if we call add(3), the function will return 3, because the default value of 0 is used for the y parameter.

### Optional Chaining - Vanilla JS

-   In JavaScript, the optional chaining operator (?.) is a new feature that allows you to access properties of an object without worrying about whether the object or the property is null or undefined. It's a shorthand for a common pattern of checking for null or undefined before accessing an object's property. If the property does not exists, it returns undefined instead of throwing an error.

-   For example, consider the following code, which accesses the firstName property of an object:

```js
const person = { name: { first: "John", last: "Doe" } };
console.log(person.name.first);
```

-   If the name property is null or undefined, this code will throw an error. To prevent this, we can use the optional chaining operator:

```js
console.log(person?.name?.first);
```

-   Now, if the person.name is null or undefined, this code will simply return undefined instead of throwing an error. This make the code more robust and readable.

### Fix Our Challenge

-   can use "AND" operator, to access the property if it exists.
-   can use optional chaning as well. check if `images` exist, if yes, check if `images[0]` exists, if yes, check if small property exists, and so on.
-   can also add default value either in the parameter of the function, or using the `||` operator.

#### Code

```js
import Avatar from "../../../assets/default-avatar.svg";
import React from "react";

export const Person = ({ name, nickName = "defaultValue", images }) => {
    // AND OPERATOR
    // const img = images && images[0] && images[0].small && images[0].small.url;

    // OPTIONAL CHAINING (with default value!)
    const img = images?.[0]?.small?.url || Avatar;

    return (
        <div>
            <img src={img} alt={name} style={{ width: "50px" }} />
            <h4>{name}</h4>
            <p>Nickname : {nickName}</p>
        </div>
    );
};
```

## Forms In React

### Controlled Inputs - Setup

```js
import Starter from "./tutorial/06-forms/starter/01-controlled-inputs.jsx";
```

#### Setup (For All Form Videos!)

-   The `htmlFor` attribute of `<label>` tag, and the `id` attribute of the `<input>` tag must match!

-   The below is going to be the same set-up for further videos!

```js
const ControlledInputs = () => {
    return (
        <form className='form'>
            <h4>Controlled Inputs</h4>
            <div className='form-row'>
                <label htmlFor='name' className='form-label'>
                    Name
                </label>
                <input type='text' className='form-input' id='name' />
            </div>
            <div className='form-row'>
                <label htmlFor='email' className='form-label'>
                    Email
                </label>
                <input type='email' className='form-input' id='email' />
            </div>
            <button type='submit' className='btn btn-block'>
                Submit
            </button>
        </form>
    );
};
export default ControlledInputs;
```

### Controlled Inputs - Complete

```js
import Starter from "./tutorial/06-forms/starter/01-controlled-inputs.jsx";
```

-   Whenever you hear controlled inputs, think there is going to be a state value.
-   Either all inputs can have one state value, or we can have seperate state value for each input.
-   Whenever we write something in the input field, we change the state value as well, and then can use this value for further processing.

#### Setup Challenge :

-   setup state values for each input field
-   add value attribute, and onChange attribute to each input field
-   value should be equal to the state value, onChange is used to handle the input

-   BOTH value, onChange must be present to executre controlled inputs!

-   The "value" attribute is used differently for different input types:

    -   For "button", "reset", and "submit" - it defines the text on the button
    -   For "text", "password", and "hidden" - it defines the initial (default) value of the input field, it also stores the current value inside the input field that is typed.
    -   For "checkbox", "radio", "image" - it defines the value associated with the input (this is also the value that is sent on submit)

```js
import { useState } from "react";

const ControlledInputs = () => {
    const [name, setName] = useState("");
    const [email, setEmail] = useState("");

    const handleSubmit = (e) => {
        e.preventDefault();
        console.log(name, email);
    };

    return (
        <form className='form' onSubmit={handleSubmit}>
            <h4>Controlled Inputs</h4>
            <div className='form-row'>
                <label htmlFor='name' className='form-label'>
                    Name
                </label>
                <input
                    type='text'
                    className='form-input'
                    id='name'
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
            </div>
            <div className='form-row'>
                <label htmlFor='email' className='form-label'>
                    Email
                </label>
                <input
                    type='email'
                    className='form-input'
                    id='email'
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                />
            </div>
            <button type='submit' className='btn btn-block'>
                Submit
            </button>
        </form>
    );
};
export default ControlledInputs;
```

-   When the user types something in the input field, the "value" attribute changes, and the value of this "value" attribute is set equal to the corresponding state value, and then this state value is used for further processing.

-   We can access the value inside the "value" attribute using the event object - "e" (e.target.value)

    -   target returns the element that triggered the event
    -   value returns the value inside the "value" attribute of the target element.

-   Therefore, if we are specifying the "value" attribute, it must be equal to the state value, as it needs to be changed everytime we type something. Else, we can avoid specifying the "value" attribute as well.

### User Challenge

```js
import Starter from "./tutorial/06-forms/starter/02-user-challenge.jsx";
```

#### Setup :

-   setup controlled input (name input)
-   setup onSubmit (for now just log success)
-   import data array (first array) from data.js
-   create another state value (set data as default)
-   iterate over the data array and display the users after the form
-   when the user submits the form, add a new person to the data array and display them

-   Extra Challenge: add a button and setup functionality to remove a particular user

#### Code

```js
import { useState } from "react";
import { data } from "../../../data";

const UserChallenge = () => {
    const [name, setName] = useState("");
    const [users, setUsers] = useState(data);

    const handleSubmit = (e) => {
        e.preventDefault();

        if (!name) return;
        // return if empty submission!

        const fakeId = Date.now();
        // dummy, don't use in real-projects!

        const newUser = { id: fakeId, name: name };
        setUsers([...data, newUser]);

        setName(""); // clear the input field!
        console.log("form submitted!");
    };

    const removeUser = (id) => {
        const newUser = users.filter((person) => {
            return person.id !== id;
        });
        setUsers(newUser);
    };

    return (
        <div>
            <form className='form' onSubmit={handleSubmit}>
                <h4>Add User</h4>
                <div className='form-row'>
                    <label htmlFor='name' className='form-label'>
                        Name
                    </label>
                    <input
                        type='text'
                        className='form-input'
                        id='name'
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                    />
                </div>

                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>

            <h2>Users</h2>
            {users.map((user) => {
                return (
                    <div key={user.id}>
                        <h4>{user.name}</h4>
                        <button
                            className='btn'
                            onClick={() => {
                                removeUser(user.id);
                            }}
                        >
                            Remove
                        </button>
                    </div>
                );
            })}
        </div>
    );
};
export default UserChallenge;
```

### Multiple Inputs

```js
import Starter from "./tutorial/06-forms/starter/03-multiple-inputs.jsx";
```

-   [Javascript Nuggets - Dynamic Object Keys](https://www.youtube.com/watch?v=_qxCYtWm0tw&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=3&t=97s)

#### Code

```js
// how to add object keys dynamically, using square bracket notation?
// somewhat similar to how we access array elements, arr[0]!

const person = {
    name: "john",
};
person.age = 25;
// add a new property, "age: 25"

const items = {
    "featured-items": ["item1", "item2"],
};
console.log(items["featured-items"]);
// to access string keys, use square brackets instead of "." operator!

console.log(person.name);
console.log(person["name"]);
// both display the same thing!

let appState = "loading";
// set key using square notation!

const app = {
    [appState]: true,
    // loading: true
};
console.log(app);

// add a new key/property!
const keyValue = "newKey";
app[keyValue] = "apple";
console.log(app);

// USE CASE
const state = {
    loading: true,
    name: "",
    job: "",
};

function updateState(key, value) {
    state[key] = value;
}

updateState("name", "kush"); // change the value of "name"!
updateState("job", "student"); // change the value of "job"!
updateState("city", "new-delhi"); // add a new key "city" with value "new-delhi"!
```

-   **NOTE: inputs must have the "name" attribute!**

-   We can use a single state (object) for all of the inputs, instead of setting up three seperate state values.

-   If we are setting up a single function for updating the state values on changing the input, we need to keep a track of which input field is being changed.

-   Therefore we need use the "name" attribute to track this.

#### Example

```js
import { useState } from "react";

const MultipleInputs = () => {
    // create a state (object) for all the inputs!
    const [user, setUser] = useState({
        name: "",
        email: "",
        password: "",
    });

    const handleChange = (e) => {
        console.log(e.target.value);
        // don't know which input field has the value?
        // therefore, we will utilize the name attribute!

        setUser({ ...user, [e.target.name]: e.target.value });
        // the value inside the "name" attribute MUST match the property name inside the state object!
    };
    const handleSubmit = (e) => {
        e.preventDefault();
        console.log(user);
    };

    return (
        <div>
            <form className='form' onSubmit={handleSubmit}>
                <h4>Multiple Inputs!</h4>
                {/* name */}
                <div className='form-row'>
                    <label htmlFor='name' className='form-label'>
                        Name
                    </label>
                    <input
                        type='text'
                        className='form-input'
                        id='name'
                        value={user.name}
                        onChange={handleChange}
                        name='name'
                    />
                </div>
                {/* email */}
                <div className='form-row'>
                    <label htmlFor='email' className='form-label'>
                        Email
                    </label>
                    <input
                        type='email'
                        className='form-input'
                        id='email'
                        value={user.email}
                        onChange={handleChange}
                        name='email'
                    />
                </div>
                {/* email */}
                <div className='form-row'>
                    <label htmlFor='password' className='form-label'>
                        Password
                    </label>
                    <input
                        type='password'
                        className='form-input'
                        id='password'
                        value={user.password}
                        onChange={handleChange}
                        name='password'
                    />
                </div>

                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>
        </div>
    );
};
export default MultipleInputs;
```

### Other Inputs

```js
import Starter from "./tutorial/06-forms/starter/04-other-inputs.jsx";
```

-   Take a look at checkbox input!

-   Also look at select input (list of options)!

#### Checkbox

```js
import { useState } from "react";
const frameworks = ["react", "angular", "vue", "svelte"];

const OtherInputs = () => {
    const [shipping, setShipping] = useState(false);

    const handleShipping = (e) => {
        console.log(e.target.checked);
        setShipping(e.target.checked);
    };

    return (
        <div>
            <form className='form'>
                <h4>Other Inputs</h4>
                {/* name */}
                <div className='form-row' style={{ textAlign: "left" }}>
                    <label htmlFor='shipping'>Free Shipping </label>
                    <input
                        type='checkbox'
                        name='shipping'
                        id='shipping'
                        checked={shipping}
                        onChange={handleShipping}
                    />
                </div>
                <div className='form-row' style={{ textAlign: "left" }}>
                    <label htmlFor='framework' className='form-label'>
                        Framework
                    </label>
                </div>
                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>
        </div>
    );
};
export default OtherInputs;
```

-   For checkbox, we use the "checked" attribute instead of the "value" attribute

-   The checked attribute returns true or false, depending whether checkbox ticked or not

#### Select List

```js
import { useState } from "react";
const frameworks = ["react", "angular", "vue", "svelte"];

const OtherInputs = () => {
    const [shipping, setShipping] = useState(false);
    const [framework, setFramework] = useState("react");

    const handleShipping = (e) => {
        console.log(e.target.checked);
        setShipping(e.target.checked);
    };
    const handleFramework = (e) => {
        setFramework(e.target.value);
    };

    return (
        <div>
            <form className='form'>
                <h4>Other Inputs</h4>
                {/* name */}
                <div className='form-row' style={{ textAlign: "left" }}>
                    <label htmlFor='shipping'>Free Shipping </label>
                    <input
                        type='checkbox'
                        name='shipping'
                        id='shipping'
                        checked={shipping}
                        onChange={handleShipping}
                    />
                </div>
                <div className='form-row' style={{ textAlign: "left" }}>
                    <label htmlFor='framework' className='form-label'>
                        Framework
                    </label>
                    <select
                        name='framework'
                        id='framework'
                        value={framework}
                        onChange={handleFramework}
                    >
                        {frameworks.map((framework) => {
                            return <option key={framework}>{framework}</option>;
                        })}
                    </select>
                </div>
                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>
        </div>
    );
};
export default OtherInputs;
```

-   Set up state value that represents what option the user has selected

-   The "value" attribute of the "select" tag represents the currently selected value

### FormData API (Optional)

```js
import Starter from "./tutorial/06-forms/starter/05-form-data.jsx";
```

-   [JS Nuggets - FormData API](https://youtu.be/5-x4OUM-SP8)

-   a nifty alternative to controlled inputs!

-   a great solution when you have bunch of inputs!

-   help us to submit the form with uncontrolled inputs, without referencing state values!

-   The FormData interface provides a way to construct a set of key/value pairs representing form fields and their values, which can be sent using the fetch() or XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".

-   inputs must have the "name" attribute

#### Code

```js
import { useState } from "react";

const UncontrolledInputs = () => {
    const [value, setValue] = useState(0);

    const handleSubmit = (e) => {
        e.preventDefault();

        const formData = new FormData(e.currentTarget);
        // pass in a form element in the API!
        console.log(formData);

        // how to access the values?
        const email = formData.get("email");
        // pass in the value inside the "name" attribute of the input field!
        console.log(email);

        // alternative approach!
        console.log([...formData.entries()]);
        // each field and it's value is an array!
        // store all of these arrays in an array!
        // therefore, returns an array of arrays!

        // best approach!
        const newUser = Object.fromEntries(formData);
        console.log(newUser);

        // clear the input fields!
        setValue(value + 1); // to re-render the application!
        e.currentTarget.reset(); // reset the form values!
    };

    return (
        <div>
            <form className='form' onSubmit={handleSubmit}>
                <h4>Form Data API</h4>
                {/* name */}
                <div className='form-row'>
                    <label htmlFor='name' className='form-label'>
                        Name
                    </label>
                    <input
                        type='text'
                        className='form-input'
                        id='name'
                        name='name'
                    />
                </div>
                {/* email */}
                <div className='form-row'>
                    <label htmlFor='email' className='form-label'>
                        Email
                    </label>
                    <input
                        type='email'
                        className='form-input'
                        id='email'
                        name='email'
                    />
                </div>
                {/* password */}
                <div className='form-row'>
                    <label htmlFor='password' className='form-label'>
                        Password
                    </label>
                    <input
                        type='password'
                        className='form-input'
                        id='password'
                        name='password'
                    />
                </div>

                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>
        </div>
    );
};
export default UncontrolledInputs;
```

##### Note #1

-   e.target refers to the DOM element, that fires off the event.
-   e.currentTarget refers to the DOM element, to which the event listener is attached to (in this case the form).

##### Note #2

-   FormData API help us easily access all of the inputs as well as their values in our form.
-   `Object.fromEntries("form-element")` - converts an array of key value pairs, into an object of key value pairs.

##### Note #3

-   The reset() method is a built-in method in HTML that can be used to reset all form controls to their initial values. When this method is called on a form element, it will clear any user-entered data and reset the values of all form elements to their default values.

## useRef Hook

```js
import Starter from "./tutorial/07-useRef/starter/01-useRef-basics.jsx";
```

-   it is a lot like useState, preserves the value between renders

-   used to access DOM nodes/elements

-   DOES NOT TRIGGER A RE-RENDER!

#### Setup :

-   think of useRef like a container
-   can be used to submit a form, with uncontrolled inputs
-   useRef returns an object, that contains a "current" property
-   the current property is equal to the default value that is provided
-   we have two ways to set the value:

    -   set refContainer equal to any of the DOM nodes (using "ref" attribute)
    -   using some kind of functionality

#### Example #1

```js
import { useEffect, useRef, useState } from "react";

const UseRefBasics = () => {
    const [value, setValue] = useState(0);
    const refContaniner = useRef(null);
    console.log(refContaniner);
    // shows null, as it is invoked before the component is mounted!

    useEffect(() => {
        console.log(refContaniner);
        // shows the form element, as it is invoked after component mounted!
    });
    const handleSubmit = (e) => {
        e.preventDefault();

        // access the current property, which contains a DOM element!
        const name = refContaniner.current.value;
        console.log(name);
    };

    return (
        <div>
            <form className='form' onSubmit={handleSubmit}>
                <div className='form-row'>
                    <label htmlFor='name' className='form-label'>
                        Name
                    </label>
                    <input
                        type='text'
                        id='name'
                        className='form-input'
                        ref={refContaniner}
                        // set the useRef hook equal to a DOM node!
                    />
                </div>
                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>
            <h1>Value : {value}</h1>
            <button onClick={() => setValue(value + 1)} className='btn'>
                Increase
            </button>
        </div>
    );
};

export default UseRefBasics;
```

-   Avoid running a certain functionality, during the initial render!

-   useRef does not trigger re-render, therefore no need to pass empty dependency array in useEffect to avoid infinite loop!

#### Example #2

```js
import { useEffect, useRef, useState } from "react";

const UseRefBasics = () => {
    const [value, setValue] = useState(0);
    const isMounted = useRef(false);

    useEffect(() => {
        // initial render
        if (!useRef.current) {
            useRef.current = true;
            return;
        }
        // state re-renders
        console.log(isMounted);
    }, [value]);

    return (
        <div>
            <form className='form'>
                <div className='form-row'>
                    <label htmlFor='name' className='form-label'>
                        Name
                    </label>
                    <input type='text' id='name' className='form-input' />
                </div>
                <button type='submit' className='btn btn-block'>
                    Submit
                </button>
            </form>
            <h1>Value : {value}</h1>
            <button onClick={() => setValue(value + 1)} className='btn'>
                Increase
            </button>
        </div>
    );
};

export default UseRefBasics;
```

#### Focus On Input Field

```js
useEffect(() => {
    refContainer.current.focus();
    // focus on the input, when page loads
});
```

## Custom Hooks

```js
import Starter from "./tutorial/08-custom-hooks/starter/01-toggle.jsx";
```

-   used for abstracting some functionality
-   same rules apply as regular hooks
-   simplify component (less code)
-   re-use functionality

#### toggle.jsx

```js
import { useState } from "react";

const ToggleExample = () => {
    const [show, setShow] = useState(false);
    return (
        <div>
            <h4>Toggle Custom Hook</h4>
            <button className='btn' onClick={() => setShow(!show)}>
                Toggle
            </button>
            {show && <h4>Some Stuff!</h4>}
        </div>
    );
};
export default ToggleExample;
```

-   Suppose, a lot of components require this functionality.

-   We can set-up a custom hook, useToggle(), in useToggle.js file!

-   We can return anything in the custom hook, in this case it is similar to a useState!

#### useToggle.js

```js
import { useState } from "react";

const useToggle = (defaultValue) => {
    // default value!
    const [show, setShow] = useState(defaultValue);

    // function!
    const toggle = () => {
        setShow(!show);
    };

    return [show, toggle];
    // return the default value that is passed to the custom hook!
    // return the function that is used to change the custom hook!
    // return an array of 2 elements, like useState!
};

export default useToggle;
```

#### toggle.jsx

```js
import useToggle from "./useToggle";

const ToggleExample = () => {
    const [show, toggle] = useToggle(false);
    // use the custom hook!

    return (
        <div>
            <h4>Toggle Custom Hook</h4>
            <button className='btn' onClick={toggle}>
                Toggle
            </button>
            {show && <h4>Some Stuff!</h4>}
        </div>
    );
};
export default ToggleExample;
```

#### Setup Challenge :

-   in App.jsx import 02-fetch-data
-   try to understand what the component does
-   now, try to setup a custom hook, that fetches the data
-   hint: hook should return isLoading, isError, user and take url as parameter!

#### Starter Component

```js
const useFetchPerson = (url) => {
    const [isLoading, setIsLoading] = useState(true);
    const [isError, setIsError] = useState(false);
    const [user, setUser] = useState(null);

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const resp = await fetch(url);
                if (!resp.ok) {
                    setIsError(true);
                    setIsLoading(false);
                    return;
                }
                const user = await resp.json();
                setUser(user);
            } catch (error) {
                setIsError(true);
            }
            setIsLoading(false);
        };
        fetchUser();
    }, []);

    return { isLoading, isError, user };
};

export default useFetchPerson;
```

#### useFetchPerson.js (Custom Hook)

```js
import { useState, useEffect } from "react";

const useFetchPerson = (url) => {
    const [isLoading, setIsLoading] = useState(true);
    const [isError, setIsError] = useState(false);
    const [user, setUser] = useState(null);

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const resp = await fetch(url);
                if (!resp.ok) {
                    setIsError(true);
                    setIsLoading(false);
                    return;
                }
                const user = await resp.json();
                setUser(user);
            } catch (error) {
                setIsError(true);
            }
            setIsLoading(false);
        };
        fetchUser();
    }, []);

    // return an object from the custom hook!
    return { isLoading, isError, user };
};

export default useFetchPerson;
```

#### Final Component

```js
import useFetch from "./useFetch";
const url = "https://api.github.com/users/QuincyLarson";

const FetchData = () => {
    const { isLoading, isError, data: user } = useFetch(url);

    if (isLoading) {
        return <h2>Loading...</h2>;
    }
    if (isError) {
        return <h2>There was an error!</h2>;
    }

    const { avatar_url, name, company, bio } = user;
    return (
        <div>
            <img
                style={{ width: "150px", borderRadius: "25px" }}
                src={avatar_url}
                alt={name}
            />
            <h2>{name}</h2>
            <h4>Works At : {company}</h4>
            <p>{bio}</p>
        </div>
    );
};
export default FetchData;
```

### Generic Fetch

-   **A more general approach of creating a custom hook for fetching any type of data!**

#### useFetch.js (Custom Hook)

```js
import { useState, useEffect } from "react";

const useFetch = (url) => {
    const [isLoading, setIsLoading] = useState(true);
    const [isError, setIsError] = useState(false);
    const [data, setData] = useState(null); // change state name!

    useEffect(() => {
        const fetchData = async () => {
            try {
                const resp = await fetch(url);
                if (!resp.ok) {
                    setIsError(true);
                    setIsLoading(false);
                    return;
                }
                const response = await resp.json(); // change name to response!
                setData(response);
            } catch (error) {
                setIsError(true);
            }
            setIsLoading(false);
        };
        fetchData();
    }, []);

    return { isLoading, isError, data };
};

export default useFetch;
```

## Context API

```js
import Starter from "./tutorial/09-context-api/starter";
```

#### Setup Challenge :

-   create three components and nest them in such way :

-   Navbar.jsx (top-level component)

    -   NavLinks.jsx (nested inside Navbar)

        -   UserContainer.jsx (nested inside NavLinks)

-   import Navbar.jsx in App.jsx

-   in Navbar.jsx setup:

    -   a user state value
        -   default value = {name:'something'}
    -   logout function
        -   function that sets user state back to null

-   pass both of these things down to UserContainer.jsx using prop drilling!

-   display the user along with the logout button

-   on clicking the button, set the user back to null

-   if user is null, display `<p>Please Login</p>` in UserContainer

#### Purpose

-   the purpose is to show that prop drilling can be a pain in the ass.

-   we will pass down the user state value, along with the logout function using prop drilling to the UserContainer.jsx component!

-   for this, the prop must pass through NavLinks component, as it is the immediate child of NavBar! If several components exist in between, prop drilling can become tedious!

#### Setup Using Prop Drilling!

##### Navbar.jsx

```js
import { useState } from "react";
import NavLinks from "./NavLinks";

const Navbar = () => {
    const [user, setUser] = useState({ name: "bob" });

    const logout = () => {
        setUser(null);
    };

    return (
        <nav className='navbar'>
            <h5>CONTEXT API</h5>
            <NavLinks user={user} logout={logout} />
            {/* pass the props down to the child */}
        </nav>
    );
};
export default Navbar;
```

##### NavLinks.jsx

```js
import UserContainer from "./UserContainer";

const NavLinks = ({ user, logout }) => {
    return (
        <div className='nav-container'>
            <ul className='nav-links'>
                <li>
                    <a href='#'>Home</a>
                </li>
                <li>
                    <a href='#'>About</a>
                </li>
            </ul>
            <UserContainer user={user} logout={logout} />
            {/* pass the props down to the child */}
        </div>
    );
};
export default NavLinks;
```

##### UserContainer.jsx

```js
const UserContainer = ({ user, logout }) => {
    return (
        <div className='user-container'>
            {user ? (
                <>
                    <p>Hello There, {user?.name?.toUpperCase()}</p>
                    <button type='button' className='btn' onClick={logout}>
                        Logout
                    </button>
                </>
            ) : (
                <p>Please Login</p>
            )}
        </div>
    );
};
export default UserContainer;
```

-   Now, we will use context api, to bypass the middle elements, to directly pass down the props to the grandchild!

### Setup Using Context API!

-   how to invoke context api? import from react library!

-   invoke createContext() inside the parent function

-   it is going to return two things

    -   provider component (going to use this component, in our project)

    -   consumer component (use useContext hook, instead of this component)

```js
import { createContext } from "react";

export const NavbarContext = createContext();

console.log(NavbarContext);
```

-   go the parent element, that provides the values, and wrap the return inside the provider.

-   provider has a "value" prop, and the value inside this "value" prop can be accessed by any component inside the component tree!

```js
import { createContext } from "react";
import { useState } from "react";
import NavLinks from "./NavLinks";

// invoke the context api!
export const NavbarContext = createContext();

const Navbar = () => {
    const [user, setUser] = useState({ name: "bob" });

    const logout = () => {
        setUser(null);
    };

    return (
        // wrap the return inside provider!
        <NavbarContext.Provider value={{ user: user, logout: logout }}>
            <nav className='navbar'>
                <h5>CONTEXT API</h5>
                <NavLinks />
            </nav>
        </NavbarContext.Provider>
    );
};
export default Navbar;
```

-   Now, we can bypass the NavLinks component, and access user, logout directly inside UserContainer.jsx

-   Need two things:

    -   NavBar context

    -   useContext hook

-   useContext() is a special hook, that looks for the context coming from the parent!

##### Navbar.jsx

```js
import { createContext } from "react";
import { useState } from "react";
import NavLinks from "./NavLinks";

export const NavbarContext = createContext();

const Navbar = () => {
    const [user, setUser] = useState({ name: "bob" });

    const logout = () => {
        setUser(null);
    };

    return (
        <NavbarContext.Provider value={{ user: user, logout: logout }}>
            <nav className='navbar'>
                <h5>CONTEXT API</h5>
                <NavLinks />
            </nav>
        </NavbarContext.Provider>
    );
};
export default Navbar;
```

##### UserContainer.jsx

```js
import { useContext } from "react";
import { NavbarContext } from "./Navbar";

const UserContainer = () => {
    // can access the values from the parent directly!
    const value = useContext(NavbarContext);
    console.log(value);

    return "hello world";
};
export default UserContainer;
```

##### UserContainer.jsx

```js
import { useContext } from "react";
import { NavbarContext } from "./Navbar";

const UserContainer = () => {
    const { user, logout } = useContext(NavbarContext);
    // destructure to grab the properties directly!

    return (
        <div className='user-container'>
            {user ? (
                <>
                    <p>Hello There, {user.name.toUpperCase()}</p>
                    <button type='button' className='btn' onClick={logout}>
                        logout
                    </button>
                </>
            ) : (
                <p>Please Login</p>
            )}
        </div>
    );
};
export default UserContainer;
```

#### Use Custom Hook

-   create a custom hook, to simplify the code even further!

##### Navbar.jsx

```js
import { createContext } from "react";
import { useState } from "react";
import NavLinks from "./NavLinks";

export const NavbarContext = createContext();

// custom hook!
import { useContext } from "react";

export const useAppContext = () => {
    return useContext(NavbarContext);
    // directly return the object passed in the value!
};
// custom hook end!

const Navbar = () => {
    const [user, setUser] = useState({ name: "bob" });

    const logout = () => {
        setUser(null);
    };

    return (
        <NavbarContext.Provider value={{ user: user, logout: logout }}>
            <nav className='navbar'>
                <h5>CONTEXT API</h5>
                <NavLinks />
            </nav>
        </NavbarContext.Provider>
    );
};
export default Navbar;
```

##### UserContainer.jsx

```js
import { useAppContext } from "./Navbar";

const UserContainer = () => {
    const { user, logout } = useAppContext();
    // destructure to grab the properties directly!

    return (
        <div className='user-container'>
            {user ? (
                <>
                    <p>Hello There, {user.name.toUpperCase()}</p>
                    <button type='button' className='btn' onClick={logout}>
                        logout
                    </button>
                </>
            ) : (
                <p>Please Login</p>
            )}
        </div>
    );
};
export default UserContainer;
```

### Setup Global Context!

-   **provide some data, to all of our components in our application!**

#### Setup :

-   create a new VITE project

-   code inside global-context vite app

```sh
npm create vite@latest global-context -- --template react

npm install && npm run dev
```

##### Step #1

-   in src folder, create a new file "context.jsx"
-   setup a global context with the name as "GlobalContext"
-   setup a new component (AppContext) with one state value
-   return GlobalContext.Provider from AppContext function/component

##### Step #2

-   wrap our entire application (main.jsx) inside the AppContext component
-   this basically wraps our entire application inside GlobalContext.Provider
-   therefore, it allows us to access the value inside the "value" attribute anywhere inside our application!

##### Step #3

-   need to pass children prop (fix error)
-   setup a custom hook for easy access
-   check in App.jsx if working
-   log value of name

## useReducer Hook

```js
import Starter from "./tutorial/10-useReducer/starter/01-useReducer.jsx";
```

-   can consider useReducer hook as a light version of Redux!
-   in a large project, can become difficult to manage so many states
-   therefore, we use state management libraries like redux, for easier code management
-   however, these state management libraries are difficult to use and understand, and requires practice

#### Setup Challenge :

-   let's add a reset functionality
-   create a function that sets the people back to the default data array
-   create another button, similar to the clear button, for the reset functionality
-   use conditional rendering to toggle between the buttons, depending on people values

#### Code

```js
import { data } from "../../../data";
import { useState } from "react";

const UseStateArray = () => {
    const [people, setPeople] = useState(data);

    const removeItem = (id) => {
        const newPeople = people.filter((person) => {
            return person.id !== id;
        });
        setPeople(newPeople);
    };
    const clearAllItems = () => {
        setPeople([]);
    };
    const resetList = () => {
        setPeople(data);
    };

    return (
        <div>
            {people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}

            {people.length < 1 ? (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={resetList}
                >
                    Reset List
                </button>
            ) : (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={clearAllItems}
                >
                    Remove All
                </button>
            )}
        </div>
    );
};

export default UseStateArray;
```

### Refactor To useReducer!

-   with useReducer, need to pass 2 things:
    -   a reducer, a function that is going to manipulate/control the state
    -   the default state and its value

#### Code

```js
// default state!
const defaultState = {
    people: data,
};

// reducer function!
const reducer = () => {};

const ReducerBasics = () => {
    // useReducer hook!
    useReducer(reducer, defaultState);
};
```

-   useReducer returns a state value, along with a dispatch
-   the dispatch is a function, that is used to control the state
-   however, the syntax is a little bit different than that from useState
-   in the dispatch, we will pass in an action (what you want do?)
-   then it is going to go through the reducer function we have set up
-   and whatever we get back from the reducer, will be our new state and its value

#### Initial Setup (Remove useState)

```js
import { data } from "../../../data";
import { useReducer, useState } from "react";

// default state!
const defaultState = {
    people: data,
};

// reducer function!
const reducer = () => {};

const ReducerBasics = () => {
    // useReducer hook!
    const [state, dispatch] = useReducer(reducer, defaultState);

    const removeItem = (id) => {
        // const newPeople = people.filter((person) => {
        //     return person.id !== id;
        // });
        // setPeople(newPeople);
    };
    const clearAllItems = () => {
        // setPeople([]);
    };
    const resetList = () => {
        // setPeople(data);
    };
    console.log(state);

    return (
        <div>
            {state.people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}

            {state.people.length < 1 ? (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={resetList}
                >
                    Reset List
                </button>
            ) : (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={clearAllItems}
                >
                    Remove All
                </button>
            )}
        </div>
    );
};

export default ReducerBasics;
```

#### Reducer Setup

-   dispatch something called action, and the action is handled by the reducer

-   whatever gets returned from the reducer, becomes the new state

-   the reducer function receives two things

    -   the state right before the update

    -   and the action (what are we trying to do!)

-   invoke the dispatch, to update the state

-   MUST MUST MUST pass in the type property in an object inside dispatch

-   this type/action is handled inside the reducer function

-   the reducer always returns the new state value, if we don't return anything it returns undefined state as the new state!

#### Code (First Dispatch)

```js
import { data } from "../../../data";
import { useReducer, useState } from "react";

// default state!
const defaultState = {
    people: data,
    isLoading: false,
};

// reducer function!
const reducer = (state, action) => {
    if (action.type == "CLEAR_LIST") {
        // spread out the values, to preserve the isLoading state!
        return { ...state, people: [] };
    }
};

const ReducerBasics = () => {
    // useReducer hook!
    const [state, dispatch] = useReducer(reducer, defaultState);

    const removeItem = (id) => {
        // const newPeople = people.filter((person) => {
        //     return person.id !== id;
        // });
        // setPeople(newPeople);
    };
    const clearAllItems = () => {
        dispatch({ type: "CLEAR_LIST" });
        // setPeople([]);
    };
    const resetList = () => {
        // setPeople(data);
    };
    console.log(state);

    return (
        <div>
            {state.people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}

            {state.people.length < 1 ? (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={resetList}
                >
                    Reset List
                </button>
            ) : (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={clearAllItems}
                >
                    Remove All
                </button>
            )}
        </div>
    );
};

export default ReducerBasics;
```

#### Actions and Default State

-   The common convention is to use a variable for storing the type of action, to avoid typos.

#### Example

```js
import { data } from "../../../data";
import { useReducer, useState } from "react";

const defaultState = {
    people: data,
    isLoading: false,
};

// define action variables!
const CLEAR_LIST = "CLEAR_LIST";
const RESET_LIST = "RESET_LIST";
const REMOVE_ITEM = "REMOVE_ITEM";

const reducer = (state, action) => {
    if (action.type == "CLEAR_LIST") {
        return { ...state, people: [] };
    }

    return state;
    // if no conditions match, return the same state to avoid error!
};

const ReducerBasics = () => {
    const [state, dispatch] = useReducer(reducer, defaultState);

    const removeItem = (id) => {
        // const newPeople = people.filter((person) => {
        //     return person.id !== id;
        // });
        // setPeople(newPeople);
    };
    const clearAllItems = () => {
        dispatch({ type: CLEAR_LIST });
        // setPeople([]);
    };
    const resetList = () => {
        // setPeople(data);
    };
    console.log(state);

    return (
        <div>
            {state.people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}

            {state.people.length < 1 ? (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={resetList}
                >
                    Reset List
                </button>
            ) : (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={clearAllItems}
                >
                    Remove All
                </button>
            )}
        </div>
    );
};

export default ReducerBasics;
```

-   How to handle errors?

-   We can either return the same state, if none of the conditions match, or we can throw an error!

#### Code

```js
const reducer = (state, action) => {
    if (action.type == "CLEAR_LIST") {
        return { ...state, people: [] };
    }

    // return state;
    throw new Error(`no matching "${action.type} - action type!"`);
};
```

#### Reset List Challenge

-   reset the list back to original data array!

#### Code

```js
import { data } from "../../../data";
import { useReducer, useState } from "react";

const defaultState = {
    people: data,
    isLoading: false,
};

// define action variables!
const CLEAR_LIST = "CLEAR_LIST";
const RESET_LIST = "RESET_LIST";
const REMOVE_ITEM = "REMOVE_ITEM";

const reducer = (state, action) => {
    if (action.type == CLEAR_LIST) {
        return { ...state, people: [] };
    }
    if (action.type === RESET_LIST) {
        return { ...state, people: data };
    }

    throw new Error(`no matching "${action.type} - action type!"`);
};

const ReducerBasics = () => {
    const [state, dispatch] = useReducer(reducer, defaultState);

    const removeItem = (id) => {
        // const newPeople = people.filter((person) => {
        //     return person.id !== id;
        // });
        // setPeople(newPeople);
    };
    const clearAllItems = () => {
        dispatch({ type: CLEAR_LIST });
    };
    const resetList = () => {
        dispatch({ type: RESET_LIST });
    };
    console.log(state);

    return (
        <div>
            {state.people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}

            {state.people.length < 1 ? (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={resetList}
                >
                    Reset List
                </button>
            ) : (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={clearAllItems}
                >
                    Remove All
                </button>
            )}
        </div>
    );
};

export default ReducerBasics;
```

#### Remove Person Challenge

-   remove a single person

-   hint: add an extra property "id" in the dispatch object!

#### Code

```js
import { data } from "../../../data";
import { useReducer, useState } from "react";

const defaultState = {
    people: data,
    isLoading: false,
};

// define action variables!
const CLEAR_LIST = "CLEAR_LIST";
const RESET_LIST = "RESET_LIST";
const REMOVE_ITEM = "REMOVE_ITEM";

const reducer = (state, action) => {
    if (action.type == CLEAR_LIST) {
        return { ...state, people: [] };
    }
    if (action.type === RESET_LIST) {
        return { ...state, people: data };
    }
    if (action.type === REMOVE_ITEM) {
        const newPeople = state.people.filter((person) => {
            return person.id !== action.payload.id;
        });
        return { ...state, people: newPeople };
    }

    throw new Error(`no matching "${action.type} - action type!"`);
};

const ReducerBasics = () => {
    const [state, dispatch] = useReducer(reducer, defaultState);

    const removeItem = (id) => {
        dispatch({ type: REMOVE_ITEM, payload: { id: id } });
    };
    const clearAllItems = () => {
        dispatch({ type: CLEAR_LIST });
    };
    const resetList = () => {
        dispatch({ type: RESET_LIST });
    };
    console.log(state);

    return (
        <div>
            {state.people.map((person) => {
                const { id, name } = person;
                return (
                    <div key={id}>
                        <h4>{name}</h4>
                        <button onClick={() => removeItem(id)}>
                            Remove Item
                        </button>
                    </div>
                );
            })}

            {state.people.length < 1 ? (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={resetList}
                >
                    Reset List
                </button>
            ) : (
                <button
                    type='button'
                    className='btn'
                    style={{ marginTop: "2rem" }}
                    onClick={clearAllItems}
                >
                    Remove All
                </button>
            )}
        </div>
    );
};

export default ReducerBasics;
```

### Import / Export

-   as we increase the actions, the code inside the reducer also increases.

-   therefore, the code becomes hard to read and manage!

#### Solution

-   create new file - actions.js

    -   copy/paste all actions

    -   export/import actions

-   create new file - reducer.js

    -   copy/paste reducer

    -   import actions

    -   import data

    -   export/import reducer

-   code for the above is in final folder!

## Performance

### Lower State / Push The State Down

```js
import Starter from "./tutorial/11-performance/starter/01-lower-state";
```

When Does Component Re-Render :

-   When the current component's state or props change, React will re-render the current component to reflect these changes.

-   When the parent element re-renders, the child component will re-render even if the child component's state or props have not changed.

#### index.js

```js
import { useState } from "react";
import { data } from "../../../../data";
import List from "./List";

const LowerState = () => {
    const [people, setPeople] = useState(data);
    const [count, setCount] = useState(0);

    return (
        <section>
            <button
                className='btn'
                onClick={() => setCount(count + 1)}
                style={{ marginBottom: "1rem" }}
            >
                Count {count}
            </button>
            <List people={people} />
        </section>
    );
};
export default LowerState;
```

#### List.jsx

```js
import Person from "./Person";

const List = ({ people }) => {
    return (
        <div>
            {people.map((person) => {
                return <Person key={person.id} {...person} />;
            })}
        </div>
    );
};
export default List;
```

#### Person.jsx

```js
const Person = ({ name }) => {
    console.log("render");

    return (
        <div>
            <h4>{name}</h4>
        </div>
    );
};
export default Person;
```

#### Solution

-   The solution is to "lower the state"
-   Move the state variable, and the button to a seperate component (Counter.jsx)
-   Now, when we change the state of the count, only the Counter component is re-rendered, as the parent does not change!

##### Counter.jsx

```js
import { useState } from "react";

const Counter = () => {
    const [count, setCount] = useState(0);
    return (
        <button
            className='btn'
            onClick={() => setCount(count + 1)}
            style={{ marginBottom: "1rem" }}
        >
            count {count}
        </button>
    );
};
export default Counter;
```

##### index.jsx

```js
import { useState } from "react";
import { data } from "../../../../data";

import List from "./List";
import Counter from "./Counter";

const LowerState = () => {
    const [people, setPeople] = useState(data);

    return (
        <section>
            <Counter />
            <List people={people} />
        </section>
    );
};
export default LowerState;
```

### Lower State Challenge

```js
import Starter from "./tutorial/11-performance/starter/02-lower-state-challenge";
```

-   fix the re-rendering!

-   hint: set-up new component, and fix addPerson function!

-   final code inside lower-state-challenge folder!

### React.memo()

```js
import Starter from "./tutorial/11-performance/starter/03-hooks";
```

-   React.memo is a higher-order component (HOC) in React that allows you to memoize a component. This means that if the input props to the component have not changed, the memoized component will return the same result from the previous render, instead of re-rendering. This can help improve performance by avoiding unnecessary render cycles.

-   The React.memo function takes a functional component as its argument and returns a new component that has the same behavior, but with the added optimization of checking if the props have changed. If the props have not changed, the memoized component will return the cached result from the previous render.

#### Example

-   If we stop the List component from re-rendering when the index.jsx re-renders, the Person component will also not re-render.

-   Therefore we need to memoize the List component.

#### List.jsx

```js
import { memo } from "react";
import Item from "./Person";

const List = ({ people }) => {
    return (
        <div>
            {people.map((person) => {
                return <Item key={person.id} {...person} />;
            })}
        </div>
    );
};
export default memo(List);
```

#### Syntax

```js
// React.memo(Component) - returns memoized component

const MyComponent = React.memo(function MyComponent(props) {
    /* render logic */
});
```

#### Function "Gotcha"

-   Problem when we pass the function as a prop.

-   Whenever the parent element is re-rendered, the function is created again from scratch.

-   Since, we are passing the function as a prop from the parent element, and the function is created again and again, React thinks that the function that is passed as a prop is changed.

-   As a result, the child component is also re-rendered.

-   Therefore, need to fix this!

#### useCallback Hook

-   The useCallback hook is a hook in React that allows you to memoize a function. It takes two arguments: the first is the function you want to memoize, and the second is an array of dependencies. The hook will return a memoized version of the function that only changes if one of the values in the dependency array changes.

-   By memoizing the function, you can avoid unnecessary re-renders and improve the performance of your React application. The function will only be re-created if one of its dependencies changes, otherwise the same instance of the function will be returned. This can be useful in situations where you have an expensive function that you only want to recompute when its dependencies change.

-   Be careful, while specifying empty dependency array, as the function will not be created again! As a result, the values used initially in the function will be considered for all subsequent operations!

#### Example

```js
import React, { useCallback, useState } from "react";

function MyComponent() {
    const [data, setData] = useState([]);
    const handleClick = useCallback(() => {
        console.log(data);
    }, [data]);

    return (
        <div>
            <button onClick={handleClick}>Click me</button>
        </div>
    );
}
```

-   In this example, the handleClick function is memoized using useCallback and the data prop is passed as a dependency. This means that the handleClick function will only be re-created if the data argument changes.

#### useMemo Hook

-   The useMemo hook is a hook in React that allows you to memoize a value. It takes two arguments: the first is a function that returns the value you want to memoize, and the second is an array of dependencies. The hook will return the memoized value that will only change if one of the values in the dependency array changes.

-   By memoizing a value, you can avoid unnecessary calculations and improve the performance of your React application. The value will only be recalculated if one of its dependencies changes, otherwise the same instance of the value will be returned. This can be useful in situations where you have an expensive calculation that you only want to recompute when its dependencies change.

#### Example #1

```js
import React, { useMemo } from "react";

function MyComponent({ data }) {
    const processedData = useMemo(() => {
        return data.map((item) => item.toUpperCase());
    }, [data]);

    return (
        <div>
            {processedData.map((item) => (
                <div key={item}>{item}</div>
            ))}
        </div>
    );
}
```

-   In this example, the processedData value is memoized using useMemo and the data prop is passed as a dependency. This means that the processedData value will only be recalculated if the data prop changes.

#### Example #2

-   in this example, we show that we are not slowing down our component, everytime a state udpates!

-   create slowFunction.js
-   setup a function that runs for a long time
-   import in index.js and set it equal to a value

##### slowFunction.js

```js
const slowFunction = () => {
    let value = 0;
    for (let i = 0; i <= 1000000000; i++) {
        value += i;
    }
    return value;
};

export default slowFunction;
```

##### index.jsx

```js
import { useMemo, useState } from "react";
import { data } from "../../../../data";

import List from "./List";
import slowFunction from "./slowFunction";

const LowerState = () => {
    const [people, setPeople] = useState(data);
    const [count, setCount] = useState(0);

    const value = useMemo(() => {
        return slowFunction();
    }, []);
    console.log(value);

    return (
        <section>
            <button
                className='btn'
                onClick={() => setCount(count + 1)}
                style={{ marginBottom: "1rem" }}
            >
                Count {count}
            </button>
            <List people={people} />
        </section>
    );
};
export default LowerState;
```

#### useTransition Hook

```js
import Starter from "./tutorial/11-performance/starter/04-react-18";
```

-   [JS Nuggets - Array.from](https://www.youtube.com/watch?v=zg1Bv4xubwo&list=PLnHJACx3NwAfRUcuKaYhZ6T5NRIpzgNGJ&index=11&t=666s)

-   Help us to treat some functionality as less urgent.

-   Whenever user clicks on a function that requires heavy computation, the UI gets blocked.

-   useTransition is a React Hook that lets you update the state and perfom the computation without blocking the UI.

#### Example

```js
import { useState, useTransition } from "react";
const LatestReact = () => {
    const [text, setText] = useState("");
    const [items, setItems] = useState([]);
    const [isPending, startTransition] = useTransition();

    const handleChange = (e) => {
        setText(e.target.value);

        startTransition(() => {
            const newItems = Array.from({ length: 5000 }, (_, index) => {
                return (
                    <div key={index}>
                        <img src='/vite.svg' alt='' />
                    </div>
                );
            });
            setItems(newItems);
        });
    };
    return (
        <section>
            <form className='form'>
                <input
                    type='text'
                    className='form-input'
                    value={text}
                    onChange={handleChange}
                />
            </form>
            <h4>Items Below</h4>
            {isPending ? (
                "Loading..."
            ) : (
                <div
                    style={{
                        display: "grid",
                        gridTemplateColumns: "1fr 1fr 1fr",
                        marginTop: "2rem",
                    }}
                >
                    {items}
                </div>
            )}
        </section>
    );
};
export default LatestReact;
```

#### Suspense API

-   The Suspense API is a feature in React that allows you to manage the loading state of your components. It provides a way to "suspend" rendering of a component until some data has been fetched, and display a fallback UI in the meantime. This makes it easier to handle asynchronous data loading and provide a smooth user experience in your React application.

#### Example

```js
import React, { lazy, Suspense } from "react";

const DataComponent = lazy(() => import("./DataComponent"));

function MyComponent() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <DataComponent />
        </Suspense>
    );
}
```

```js
import { useState, useTransition, lazy, Suspense } from "react";
const SlowComponent = lazy(() => import("./SlowComponent"));
const LatestReact = () => {
    const [text, setText] = useState("");
    const [items, setItems] = useState([]);
    const [isPending, startTransition] = useTransition();
    const [show, setShow] = useState(false);
    const handleChange = (e) => {
        setText(e.target.value);

        startTransition(() => {
            const newItems = Array.from({ length: 5000 }, (_, index) => {
                return (
                    <div key={index}>
                        <img src='/vite.svg' alt='' />
                    </div>
                );
            });
            setItems(newItems);
        });
    };
    return (
        <section>
            <form className='form'>
                <input
                    type='text'
                    className='form-input'
                    value={text}
                    onChange={handleChange}
                />
            </form>
            <h4>Items Below</h4>
            {isPending ? (
                "Loading..."
            ) : (
                <div
                    style={{
                        display: "grid",
                        gridTemplateColumns: "1fr 1fr 1fr",
                        marginTop: "2rem",
                    }}
                >
                    {items}
                </div>
            )}
            <button onClick={() => setShow(!show)} className='btn'>
                toggle
            </button>
            {show && (
                <Suspense fallback={<h4>Loading...</h4>}>
                    <SlowComponent />
                </Suspense>
            )}
        </section>
    );
};
export default LatestReact;
```

#### Typical Setup - Wrap Entire Return In Suspense!

```js
return (
    <Suspense fallback={<h4>Loading...</h4>}>
        {/* rest of the logic */}
        <section>{show && <SlowComponent />}</section>
    </Suspense>
);
```

<hr>